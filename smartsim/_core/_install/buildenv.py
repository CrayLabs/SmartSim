import os
import platform
import site
import subprocess
import sys
import pprint
from pathlib import Path

import pkg_resources

# NOTE: This will be imported by setup.py and hence no
#       smartsim related items or non-standand library
#       items should be imported here.

# TODO:
#  - check versions of prequisites
#  - check urls
#  - ensure PyTorch versions will work for RedisAI version (should support a range)
#  - Add support for RedisAI 1.2.5
#  - use torch_version.py Version to compare versions
#      - https://github.com/pytorch/pytorch/blob/master/torch/torch_version.py
#  - include Ray versions


class SetupError(Exception):
    pass


class Versioner:
    """Buildtime configuration of third-party dependencies"""

    # compatible Python version
    PYTHON_MIN = (3, 7, 0)

    # Versions
    SMARTSIM = os.environ.get("SMARTSIM_VERSION", "0.3.2")
    SMARTSIM_SUFFIX = os.environ.get("SMARTSIM_SUFFIX", "")
    SMARTREDIS = os.environ.get("SMARTREDIS_VERSION", "0.2.0")

    # Redis
    REDIS = os.environ.get("SMARTSIM_REDIS", "6.0.8")
    REDIS_URL = os.environ.get(
        "SMARTSIM_REDIS_URL", "https://github.com/redis/redis.git/"
    )

    # RedisAI
    REDISAI = os.environ.get("SMARTSIM_REDISAI", "1.2.3")
    REDISAI_URL = os.environ.get(
        "SMARTSIM_REDISAI_URL", "https://github.com/RedisAI/RedisAI.git/"
    )

    # TORCH
    TORCH = os.environ.get("SMARTSIM_TORCH", "1.7.1")
    TORCHVISION = os.environ.get("SMARTSIM_TORCHVIS", "0.8.2")

    def __init__(self):
        # align RedisAI versions with ML packages
        if self.REDISAI == "1.2.3":
            self.TENSORFLOW = "2.4.2"
            self.ONNX = "1.7.0"
            self.SKL2ONNX = "1.9.0"
            self.ONNXML = "1.7.0"
        else:
            raise SetupError("Unsupported version of RedisAI: {}".format(self.REDISAI))

    def get_sha(self, setup_py_dir) -> str:
        """Get the git sha of the current branch"""
        try:
            sha = (
                subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=setup_py_dir)
                .decode("ascii")
                .strip()
            )
            return sha[:7]
        except Exception:
            return "Unknown"

    def onnx_packages(self):
        return [
            f"skl2onnx=={self.SKL2ONNX}",
            f"onnx=={self.ONNX}",
            f"onnxmltools=={self.ONNXML}",
        ]

    def write_version(self, setup_py_dir):
        """
        Write version info to version.py

        Use git_sha in the case where smartsim suffix is set in the environment
        """
        version = self.SMARTSIM
        if self.SMARTSIM_SUFFIX:
            git_sha = self.get_sha(setup_py_dir)
            version = f"{version}-{self.SMARTSIM_SUFFIX}-{git_sha}"

        version_file = setup_py_dir / "smartsim" / "version.py"
        with open(version_file, "w") as f:
            f.write("# This file is automatically generated by setup.py\n")
            f.write("# do not edit this file manually.\n\n")

            f.write(f"__version__ = '{version}'\n")
        return version


class BuildEnv:
    """Environment for building third-party dependencies"""

    # Compiler overrides
    CC = os.environ.get("CC", "gcc")
    CXX = os.environ.get("CXX", "g++")
    CFLAGS = os.environ.get("CFLAGS", "")
    CXXFLAGS = os.environ.get("CXXFLAGS", "")

    # build overrides
    MALLOC = os.environ.get("MALLOC", "libc")
    JOBS = os.environ.get("BUILD_JOBS", 1)

    # check for CC/GCC/ETC
    CHECKS = int(os.environ.get("NO_CHECKS", 0))
    PLATFORM = sys.platform

    def __init__(self, run_checks=True):
        if run_checks:
            self.check_dependencies()

    def check_dependencies(self):
        deps = [
            "git",
            "git-lfs",
            "make",
            "cmake",
            self.CC,
            self.CXX
        ]
        if int(self.CHECKS) == 0:
            for dep in deps:
                self.check_build_dependency(dep)

    def __call__(self):
        # return the build env for the build process
        env = os.environ.copy()
        env.update({
            "CC": self.CC,
            "CXX": self.CXX,
            "CFLAGS": self.CFLAGS,
            "CXXFLAGS": self.CXXFLAGS
            })
        return env

    def __str__(self):
        env = {
            "CC": self.CC,
            "CXX": self.CXX,
            "CFLAGS": self.CFLAGS,
            "CXXFLAGS": self.CXXFLAGS,
            "PYTHON_VERSION": self.python_version,
            "PLATFORM": self.PLATFORM,
            "MALLOC": self.MALLOC,
            "JOBS": self.JOBS
        }
        return pprint.pformat(env)

    @property
    def python_version(self):
        return platform.python_version()

    def is_compatible_python(self, python_min):
        if sys.version_info < python_min:
            return False
        return True

    def is_windows(self):
        if self.PLATFORM in ["win32", "cygwin", "msys"]:
            return True
        return False

    def is_macos(self):
        if self.PLATFORM == "darwin":
            return True
        return False

    @property
    def site_packages_path(self):
        site_path = Path(site.getsitepackages()[0]).resolve()
        return site_path

    @property
    def torch_cmake_path(self):
        site_path = self.site_packages_path
        torch_path = site_path.joinpath("torch/share/cmake/Torch/").resolve()
        return str(torch_path)

    @staticmethod
    def get_cudnn_env():
        env = {
            "CUDNN_LIBRARY": os.environ.get("CUDNN_LIBRARY", None),
            "CUDNN_INCLUDE_DIR": os.environ.get("CUDNN_INCLUDE_DIR", None),
            "CUDNN_LIBRARY_PATH": os.environ.get("CUDNN_LIBRARY_PATH", None),
            "CUDNN_INCLUDE_PATH": os.environ.get("CUDNN_INCLUDE_PATH", None)
        }
        torch_cudnn_vars = ["CUDNN_LIBRARY", "CUDNN_INCLUDE_DIR"]
        caffe_cudnn_vars = ["CUDNN_INCLUDE_PATH", "CUDNN_LIBRARY_PATH"]

        torch_set = all([var in os.environ for var in torch_cudnn_vars])
        caffe_set = all([var in os.environ for var in caffe_cudnn_vars])

        # check for both sets, if only one exists, set the other
        # this handles older versions which use different env vars
        if not torch_set and not caffe_set:
            return None # return None as we don't want to raise a warning here
        if torch_set and not caffe_set:
            env["CUDNN_INCLUDE_PATH"] = env["CUDNN_INCLUDE_DIR"]
            env["CUDNN_LIBRARY_PATH"] = env["CUDNN_LIBRARY"]
        elif caffe_set and not torch_set:
            env["CUDNN_INCLUDE_DIR"] = env["CUDNN_INCLUDE_PATH"]
            env["CUDNN_LIBRARY"] = env["CUDNN_LIBRARY_PATH"]
        return env

    def check_build_dependency(self, command):
        # TODO expand this to parse and check versions.
        try:
            out = subprocess.check_output([command, "--version"])
        except OSError:
            raise RuntimeError(f"{command} must be installed to build SmartSim") from None

    @staticmethod
    def check_installed(package):
        try:
            pkg_resources.get_distribution(package)
            return True
        except pkg_resources.DistributionNotFound:
            return False

    @staticmethod
    def check_installed(package, version=None):
        try:
            installed_version = pkg_resources.get_distribution(package).version
            if version:
                installed_major, installed_minor, _ = installed_version.split(".")
                supported_major, supported_minor, _ = version.split(".")

                if int(installed_major) != int(supported_major) or int(
                    installed_minor
                ) != int(supported_minor):
                    msg = f"Incompatible version for {package} detected.\n"
                    msg = f"{package} {version} requested but {package} {installed_version}"
                    raise SetupError(msg)
            return True
        except pkg_resources.DistributionNotFound:
            return False
