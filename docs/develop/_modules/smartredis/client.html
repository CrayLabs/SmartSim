

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>smartredis.client &#8212; SmartSim 0.8.0+dev.9f40322 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom_tab_style.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.4cbf315f70debaebd550c87a6162cf0f.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script src="../../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/smartredis/client';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">SmartSim 0.8.0+dev.9f40322 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">Versions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation_instructions/basic.html">Basic Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation_instructions/platform.html">Installation on specific platforms</a></li>









<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../smartsim_zoo.html">Contributing Examples</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/getting_started/getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/online_analysis/lattice/online_analysis.html">Online Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/ml_inference/Inference-in-SmartSim.html">Online Inference</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../tutorials/ml_training/surrogate/train_surrogate.html">Online Training</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">SmartSim</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../experiment.html">Experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../run_settings.html">Run Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../batch_settings.html">Batch Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../model.html">Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ensemble.html">Ensemble</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../orchestrator.html">Orchestrator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ss_logger.html">Logger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ml_features.html">ML Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dragon.html">Dragon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/smartsim_api.html">SmartSim API</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">SmartRedis</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../smartredis.html">SmartRedis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_integration.html">Integrating into a Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_python_walkthrough.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_cpp_walkthrough.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_fortran_walkthrough.html">Fortran</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_data_structures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_dataset_conversions.html">DataSet Conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_runtime.html">Runtime Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sr_advanced_topics.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/smartredis_api.html">SmartRedis API</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">SmartDashboard</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../smartdashboard.html">SmartDashboard</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html">Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Testing</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/CrayLabs/SmartSim" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/CrayLabs/SmartSim/issues/new?title=Issue%20on%20page%20%2F_modules/smartredis/client.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for smartredis.client</h1><div class="highlight"><pre>
<span></span><span class="c1"># BSD 2-Clause License</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2021-2024, Hewlett Packard Enterprise</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="c1"># DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span>
<span class="c1"># FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="c1"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="c1"># SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="c1"># CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="c1"># OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="c1"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="c1"># pylint: disable=too-many-lines,too-many-public-methods</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">t</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">.configoptions</span> <span class="kn">import</span> <span class="n">ConfigOptions</span>
<span class="kn">from</span> <span class="nn">.error</span> <span class="kn">import</span> <span class="n">RedisConnectionError</span>
<span class="kn">from</span> <span class="nn">.smartredisPy</span> <span class="kn">import</span> <span class="n">PyClient</span>
<span class="kn">from</span> <span class="nn">.smartredisPy</span> <span class="kn">import</span> <span class="n">RedisReplyError</span> <span class="k">as</span> <span class="n">PybindRedisReplyError</span>
<span class="kn">from</span> <span class="nn">.srobject</span> <span class="kn">import</span> <span class="n">SRObject</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">Dtypes</span><span class="p">,</span> <span class="n">exception_handler</span><span class="p">,</span> <span class="n">init_default</span><span class="p">,</span> <span class="n">typecheck</span>


<div class="viewcode-block" id="Client"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client">[docs]</a><span class="k">class</span> <span class="nc">Client</span><span class="p">(</span><span class="n">SRObject</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a SmartRedis client</span>

<span class="sd">        At this time, the Client can be initialized with one of two</span>
<span class="sd">        signatures. The first version is preferred, though the second is</span>
<span class="sd">        supported (primarily for use in driver scripts). Note that the</span>
<span class="sd">        order was swapped for first two parameters in the second signature</span>
<span class="sd">        relative to previous releases of SmartRedis; this was necessary to</span>
<span class="sd">        remove ambiguity.</span>

<span class="sd">            Client(config_options: ConfigOptions=None,</span>
<span class="sd">                   logger_name: str=&quot;Default&quot;)</span>
<span class="sd">            Client(cluster: bool, address: optional(str)=None,</span>
<span class="sd">                   logger_name: str=&quot;Default&quot;)</span>

<span class="sd">        For detailed information on the first signature, please refer</span>
<span class="sd">        to the __standard_construction() method below.</span>

<span class="sd">        For detailed information on the second signature, please refer</span>
<span class="sd">        to the __address_construction() method below.</span>

<span class="sd">        :param a: The positional arguments supplied to this method;</span>
<span class="sd">                  see above for valid options</span>
<span class="sd">        :type a: tuple[any]; see above for valid options</span>
<span class="sd">        :param kw: Keyword arguments supplied to this method;</span>
<span class="sd">                   see above for valid options</span>
<span class="sd">        :type kw: dict[string, any]; see above for valid options</span>
<span class="sd">        :raises RedisConnectionError: if connection initialization fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="s2">&quot;logger_name&quot;</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;__init__() got an unexpected keyword argument &#39;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                        <span class="p">)</span>
                <span class="n">pyclient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__address_construction</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ConfigOptions</span><span class="p">)</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pyclient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__standard_construction</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type for argument 0: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only kwargs in the call</span>
            <span class="k">if</span> <span class="s2">&quot;address&quot;</span> <span class="ow">in</span> <span class="n">kw</span> <span class="ow">or</span> <span class="s2">&quot;cluster&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
                <span class="n">pyclient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__address_construction</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pyclient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__standard_construction</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pyclient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__address_construction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cluster</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">address</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">logger_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Default&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PyClient</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a SmartRedis client</span>

<span class="sd">        This construction method is primarily intended for use by driver</span>
<span class="sd">        scripts. It is preferred to set up configuration via environment</span>
<span class="sd">        variables.</span>

<span class="sd">        For clusters, the address can be a single tcp/ip address and port</span>
<span class="sd">        of a database node. The rest of the cluster will be discovered</span>
<span class="sd">        by the client itself. (e.g. address=&quot;127.0.0.1:6379&quot;)</span>

<span class="sd">        If an address is not set, the client will look for the environment</span>
<span class="sd">        variable ``SSDB`` (e.g. SSDB=&quot;127.0.0.1:6379;&quot;)</span>

<span class="sd">        :param cluster: True if connecting to a redis cluster, defaults to False</span>
<span class="sd">        :type cluster: bool</span>
<span class="sd">        :param address: Address of the database</span>
<span class="sd">        :type address: str, optional</span>
<span class="sd">        :param logger_name: Identifier for the current client</span>
<span class="sd">        :type logger_name: str</span>
<span class="sd">        :raises RedisConnectionError: if connection initialization fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">address</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__set_address</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;SSDB&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RedisConnectionError</span><span class="p">(</span><span class="s2">&quot;Could not connect to database. $SSDB not set&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PyClient</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">logger_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">PybindRedisReplyError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RedisConnectionError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__standard_construction</span><span class="p">(</span>
        <span class="n">config_options</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">ConfigOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">logger_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Default&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PyClient</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a RedisAI client</span>

<span class="sd">        The address of the Redis database is expected to be found in the</span>
<span class="sd">        SSDB environment variable (or a suffixed variable if a suffix was</span>
<span class="sd">        used when building the config_options object).</span>

<span class="sd">        :param config_options: Source for configuration data</span>
<span class="sd">        :type config_options: ConfigOptions, optional</span>
<span class="sd">        :param logger_name: Identifier for the current client</span>
<span class="sd">        :type logger_name: str</span>
<span class="sd">        :raises RedisConnectionError: if connection initialization fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">config_options</span><span class="p">:</span>
                <span class="n">pybind_config_options</span> <span class="o">=</span> <span class="n">config_options</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">PyClient</span><span class="p">(</span><span class="n">pybind_config_options</span><span class="p">,</span> <span class="n">logger_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">PyClient</span><span class="p">(</span><span class="n">logger_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PybindRedisReplyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RedisConnectionError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RedisConnectionError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a string representation of the client</span>

<span class="sd">        :return: A string representation of the client</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_client</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PyClient</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias _srobject to _client&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_srobject</span>

<div class="viewcode-block" id="Client.put_tensor"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.put_tensor">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">put_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a tensor to a Redis database</span>

<span class="sd">        The final tensor key under which the tensor is stored</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name for tensor for be stored at</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param data: numpy array of tensor data</span>
<span class="sd">        :type data: np.array</span>
<span class="sd">        :raises RedisReplyError: if put fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Dtypes</span><span class="o">.</span><span class="n">tensor_from_numpy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">put_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">put_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="Client.get_tensor"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_tensor">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a tensor from the database</span>

<span class="sd">        The tensor key used to locate the tensor</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name to get tensor from</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if get fails</span>
<span class="sd">        :return: numpy array of tensor data</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.delete_tensor"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.delete_tensor">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">delete_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete a tensor from the database</span>

<span class="sd">        The tensor key used to locate the tensor to be deleted</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name tensor is stored at</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if deletion fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">delete_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.copy_tensor"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.copy_tensor">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">copy_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy a tensor at one name to another name</span>

<span class="sd">        The source and destination tensor keys used to locate</span>
<span class="sd">        and store the tensor may be formed by applying prefixes</span>
<span class="sd">        to the supplied src_name and dest_name. See set_data_source()</span>
<span class="sd">        and use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param src_name: source name of tensor to be copied</span>
<span class="sd">        :type src_name: str</span>
<span class="sd">        :param dest_name: name to store new copy at</span>
<span class="sd">        :type dest_name: str</span>
<span class="sd">        :raises RedisReplyError: if copy operation fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="s2">&quot;src_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s2">&quot;dest_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">copy_tensor</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.rename_tensor"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.rename_tensor">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">rename_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">new_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rename a tensor in the database</span>

<span class="sd">        The old and new tensor keys used to find and relocate</span>
<span class="sd">        the tensor may be formed by applying prefixes to the supplied</span>
<span class="sd">        old_name and new_name. See set_data_source()</span>
<span class="sd">        and use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param old_name: original name of tensor to be renamed</span>
<span class="sd">        :type old_name: str</span>
<span class="sd">        :param new_name: new name for the tensor</span>
<span class="sd">        :type new_name: str</span>
<span class="sd">        :raises RedisReplyError: if rename operation fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="s2">&quot;old_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="s2">&quot;new_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">rename_tensor</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.put_dataset"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.put_dataset">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">put_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a Dataset instance into the database</span>

<span class="sd">        The final dataset key under which the dataset is stored</span>
<span class="sd">        is generated from the name that was supplied when the</span>
<span class="sd">        dataset was created and may be prefixed. See</span>
<span class="sd">        use_dataset_ensemble_prefix() for more details.</span>

<span class="sd">        All associated tensors and metadata within the Dataset</span>
<span class="sd">        instance will also be stored.</span>

<span class="sd">        :param dataset: a Dataset instance</span>
<span class="sd">        :type dataset: Dataset</span>
<span class="sd">        :raises TypeError: if argument is not a Dataset</span>
<span class="sd">        :raises RedisReplyError: if update fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;dataset&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">)</span>
        <span class="n">pybind_dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">put_dataset</span><span class="p">(</span><span class="n">pybind_dataset</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_dataset"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_dataset">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a dataset from the database</span>

<span class="sd">        The dataset key used to locate the dataset</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_dataset_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name the dataset is stored under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if retrieval fails</span>
<span class="sd">        :return: Dataset instance</span>
<span class="sd">        :rtype: Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">python_dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">from_pybind</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">python_dataset</span></div>

<div class="viewcode-block" id="Client.delete_dataset"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.delete_dataset">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">delete_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete a dataset within the database</span>

<span class="sd">        The dataset key used to locate the dataset to be deleted</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_dataset_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name of the dataset</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if deletion fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">delete_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.copy_dataset"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.copy_dataset">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">copy_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy a dataset from one key to another</span>

<span class="sd">        The source and destination dataset keys used to</span>
<span class="sd">        locate the dataset may be formed by applying prefixes</span>
<span class="sd">        to the supplied src_name and dest_name. See set_data_source()</span>
<span class="sd">        and use_dataset_ensemble_prefix() for more details.</span>

<span class="sd">        :param src_name: source name for dataset to be copied</span>
<span class="sd">        :type src_name: str</span>
<span class="sd">        :param dest_name: new name of dataset</span>
<span class="sd">        :type dest_name: str</span>
<span class="sd">        :raises RedisReplyError: if copy operation fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="s2">&quot;src_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s2">&quot;dest_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">copy_dataset</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.rename_dataset"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.rename_dataset">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">rename_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">new_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rename a dataset in the database</span>

<span class="sd">        The old and new dataset keys used to find and relocate</span>
<span class="sd">        the dataset may be formed by applying prefixes to the supplied</span>
<span class="sd">        old_name and new_name. See set_data_source()</span>
<span class="sd">        and use_dataset_ensemble_prefix() for more details.</span>

<span class="sd">        :param old_name: original name of the dataset to be renamed</span>
<span class="sd">        :type old_name: str</span>
<span class="sd">        :param new_name: new name for the dataset</span>
<span class="sd">        :type new_name: str</span>
<span class="sd">        :raises RedisReplyError: if rename operation fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="s2">&quot;old_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="s2">&quot;new_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">rename_dataset</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_function"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_function">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a callable function into the database</span>

<span class="sd">        The final script key used to store the function may be formed</span>
<span class="sd">        by applying a prefix to the supplied name.</span>
<span class="sd">        See use_model_ensemble_prefix() for more details.</span>

<span class="sd">        Function must be a callable TorchScript function and have at least</span>
<span class="sd">        one input and one output. Call the function with the Client.run_script</span>
<span class="sd">        method.</span>
<span class="sd">        Device selection is either &quot;GPU&quot; or &quot;CPU&quot;. If many GPUs are present,</span>
<span class="sd">        a zero-based index can be passed for specification e.g. &quot;GPU:1&quot;.</span>

<span class="sd">        :param name: name to store function at</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param function: callable function</span>
<span class="sd">        :type function: callable</span>
<span class="sd">        :param device: device to run function on, defaults to &quot;CPU&quot;</span>
<span class="sd">        :type device: str, optional</span>
<span class="sd">        :raises TypeError: if argument was not a callable function</span>
<span class="sd">        :raises RedisReplyError: if function failed to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Argument provided for function, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="si">}</span><span class="s2">, is not callable&quot;</span>
            <span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">fn_src</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_script</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">fn_src</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_function_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_function_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_function_multigpu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a callable function into the database for use</span>
<span class="sd">        in a multi-GPU system</span>

<span class="sd">        The final script key used to store the function may be formed</span>
<span class="sd">        by applying a prefix to the supplied name.</span>
<span class="sd">        See use_model_ensemble_prefix() for more details.</span>

<span class="sd">        Function must be a callable TorchScript function and have at least</span>
<span class="sd">        one input and one output. Call the function with the Client.run_script</span>
<span class="sd">        method.</span>

<span class="sd">        :param name: name to store function at</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param function: callable function</span>
<span class="sd">        :type function: callable</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this function</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of GPUs to use for this function</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :raises TypeError: if argument was not a callable function</span>
<span class="sd">        :raises RedisReplyError: if function failed to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Argument provided for function, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="si">}</span><span class="s2">, is not callable&quot;</span>
            <span class="p">)</span>
        <span class="n">fn_src</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_script_multigpu</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fn_src</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_script"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_script">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_script</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store a TorchScript at a key in the database</span>

<span class="sd">        The final script key used to store the script may be formed</span>
<span class="sd">        by applying a prefix to the supplied name.</span>
<span class="sd">        See use_model_ensemble_prefix() for more details.</span>

<span class="sd">        Device selection is either &quot;GPU&quot; or &quot;CPU&quot;. If many GPUs are present,</span>
<span class="sd">        a zero-based index can be passed for specification e.g. &quot;GPU:1&quot;.</span>

<span class="sd">        :param name: name to store the script under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param script: TorchScript code</span>
<span class="sd">        :type script: str</span>
<span class="sd">        :param device: device for script execution, defaults to &quot;CPU&quot;</span>
<span class="sd">        :type device: str, optional</span>
<span class="sd">        :raises RedisReplyError: if script fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="s2">&quot;script&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_script</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">script</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_script_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_script_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_script_multigpu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store a TorchScript at a key in the database</span>

<span class="sd">        The final script key used to store the script may be formed</span>
<span class="sd">        by applying a prefix to the supplied name.</span>
<span class="sd">        See use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name to store the script under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param script: TorchScript code</span>
<span class="sd">        :type script: str</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this script</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of GPUs to use in processing this script</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :raises RedisReplyError: if script fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="s2">&quot;script&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_script_multigpu</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_script_from_file"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_script_from_file">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_script_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Same as Client.set_script, but from file</span>

<span class="sd">        The final script key used to store the script may be formed</span>
<span class="sd">        by applying a prefix to the supplied name.</span>
<span class="sd">        See use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: key to store script under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param file: path to text file containing TorchScript code</span>
<span class="sd">        :type file: str</span>
<span class="sd">        :param device: device for script execution, defaults to &quot;CPU&quot;</span>
<span class="sd">        :type device: str, optional</span>
<span class="sd">        :raises RedisReplyError: if script fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_script_from_file</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_script_from_file_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_script_from_file_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_script_from_file_multigpu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Same as Client.set_script_multigpu, but from file</span>

<span class="sd">        The final script key used to store the script may be formed</span>
<span class="sd">        by applying a prefix to the supplied name.</span>
<span class="sd">        See use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: key to store script under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param file: path to text file containing TorchScript code</span>
<span class="sd">        :type file: str</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this script</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of GPUs to use in processing this script</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :raises RedisReplyError: if script fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_script_from_file_multigpu</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_script"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_script">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_script</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve a Torchscript stored in the database</span>

<span class="sd">        The script key used to locate the script</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and</span>
<span class="sd">        use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: the name at which script is stored</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if script retrieval fails</span>
<span class="sd">        :return: TorchScript stored at name</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">script</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_script</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">script</span></div>

<div class="viewcode-block" id="Client.run_script"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.run_script">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">run_script</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">fn_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute TorchScript stored inside the database</span>

<span class="sd">        The script key used to locate the script to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. Similarly, the tensor names in the</span>
<span class="sd">        input and output lists may be prefixed. See</span>
<span class="sd">        set_data_source(), use_model_ensemble_prefix(), and</span>
<span class="sd">        use_tensor_ensemble_prefix() for more details</span>

<span class="sd">        :param name: the name the script is stored under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param fn_name: name of a function within the script to execute</span>
<span class="sd">        :type fn_name: str</span>
<span class="sd">        :param inputs: database tensor names to use as script inputs</span>
<span class="sd">        :type inputs: str | list[str]</span>
<span class="sd">        :param outputs: database tensor names to receive script outputs</span>
<span class="sd">        :type outputs: str | list[str]</span>
<span class="sd">        :raises RedisReplyError: if script execution fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">fn_name</span><span class="p">,</span> <span class="s2">&quot;fn_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">run_script</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.run_script_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.run_script_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">run_script_multigpu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">fn_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute TorchScript stored inside the database</span>

<span class="sd">        The script key used to locate the script to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. Similarly, the tensor names in the</span>
<span class="sd">        input and output lists may be prefixed. See</span>
<span class="sd">        set_data_source(), use_model_ensemble_prefix(), and</span>
<span class="sd">        use_tensor_ensemble_prefix() for more details</span>

<span class="sd">        :param name: the name the script is stored under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param fn_name: name of a function within the script to execute</span>
<span class="sd">        :type fn_name: str</span>
<span class="sd">        :param inputs: database tensor names to use as script inputs</span>
<span class="sd">        :type inputs: str | list[str]</span>
<span class="sd">        :param outputs: database tensor names to receive script outputs</span>
<span class="sd">        :type outputs: str | list[str]</span>
<span class="sd">        :param offset: index of the current image, such as a processor ID</span>
<span class="sd">                         or MPI rank</span>
<span class="sd">        :type offset: int</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this script</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of gpus for which the script was stored</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :raises RedisReplyError: if script execution fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">fn_name</span><span class="p">,</span> <span class="s2">&quot;fn_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">run_script_multigpu</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">,</span> <span class="n">num_gpus</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.delete_script"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.delete_script">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">delete_script</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a script from the database</span>

<span class="sd">        The script key used to locate the script to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_model_ensemble_prefix()</span>
<span class="sd">        for more details</span>

<span class="sd">        :param name: the name the script is stored under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if script deletion fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">delete_script</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.delete_script_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.delete_script_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">delete_script_multigpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a script from the database</span>

<span class="sd">        The script key used to locate the script to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_model_ensemble_prefix()</span>
<span class="sd">        for more details</span>

<span class="sd">        :param name: the name the script is stored under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this script</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of gpus for which the script was stored</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :raises RedisReplyError: if script deletion fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">delete_script_multigpu</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_model"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_model">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a stored model</span>

<span class="sd">        The model key used to locate the model</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name of stored model</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if retrieval fails</span>
<span class="sd">        :return: model</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_model</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span></div>

<div class="viewcode-block" id="Client.set_model"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_model">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a TF, TF-lite, PT, or ONNX model in the database</span>

<span class="sd">        The final model key used to store the model</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. Similarly, the tensor names in the</span>
<span class="sd">        input and output nodes for TF models may be prefixed.</span>
<span class="sd">        See set_data_source(), use_model_ensemble_prefix(), and</span>
<span class="sd">        use_tensor_ensemble_prefix() for more details.</span>
<span class="sd">        Device selection is either &quot;GPU&quot; or &quot;CPU&quot;. If many GPUs are present,</span>
<span class="sd">        a zero-based index can be passed for specification e.g. &quot;GPU:1&quot;.</span>

<span class="sd">        :param name: name to store model under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param model: serialized model</span>
<span class="sd">        :type model: bytes</span>
<span class="sd">        :param backend: name of the backend (TORCH, TF, TFLITE, ONNX)</span>
<span class="sd">        :type backend: str</span>
<span class="sd">        :param device: name of device for execution, defaults to &quot;CPU&quot;</span>
<span class="sd">        :type device: str, optional</span>
<span class="sd">        :param batch_size: batch size for execution, defaults to 0</span>
<span class="sd">        :type batch_size: int, optional</span>
<span class="sd">        :param min_batch_size: minimum batch size for model execution, defaults to 0</span>
<span class="sd">        :type min_batch_size: int, optional</span>
<span class="sd">        :param min_batch_timeout: Max time (ms) to wait for min batch size</span>
<span class="sd">        :type min_batch_timeout: int, optional</span>
<span class="sd">        :param tag: additional tag for model information, defaults to &quot;&quot;</span>
<span class="sd">        :type tag: str, optional</span>
<span class="sd">        :param inputs: model inputs (TF only), defaults to None</span>
<span class="sd">        :type inputs: str | list[str] | None</span>
<span class="sd">        :param outputs: model outputs (TF only), defaults to None</span>
<span class="sd">        :type outputs: str | list[str] | None</span>
<span class="sd">        :raises RedisReplyError: if model fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;backend&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="s2">&quot;batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_size</span><span class="p">,</span> <span class="s2">&quot;min_batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_timeout</span><span class="p">,</span> <span class="s2">&quot;min_batch_timeout&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">backend</span><span class="p">,</span>
            <span class="n">device</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="p">,</span>
            <span class="n">min_batch_size</span><span class="p">,</span>
            <span class="n">min_batch_timeout</span><span class="p">,</span>
            <span class="n">tag</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_model_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_model_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_model_multigpu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a TF, TF-lite, PT, or ONNX model in the database for use</span>
<span class="sd">        in a multi-GPU system</span>

<span class="sd">        The final model key used to store the model</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. Similarly, the tensor names in the</span>
<span class="sd">        input and output nodes for TF models may be prefixed.</span>
<span class="sd">        See set_data_source(), use_model_ensemble_prefix(), and</span>
<span class="sd">        use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name to store model under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param model: serialized model</span>
<span class="sd">        :type model: bytes</span>
<span class="sd">        :param backend: name of the backend (TORCH, TF, TFLITE, ONNX)</span>
<span class="sd">        :type backend: str</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this model</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of GPUs to use in processing this model</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :param batch_size: batch size for execution, defaults to 0</span>
<span class="sd">        :type batch_size: int, optional</span>
<span class="sd">        :param min_batch_size: minimum batch size for model execution, defaults to 0</span>
<span class="sd">        :type min_batch_size: int, optional</span>
<span class="sd">        :param min_batch_timeout: Max time (ms) to wait for min batch size</span>
<span class="sd">        :type min_batch_timeout: int, optional</span>
<span class="sd">        :param tag: additional tag for model information, defaults to &quot;&quot;</span>
<span class="sd">        :type tag: str, optional</span>
<span class="sd">        :param inputs: model inputs (TF only), defaults to None</span>
<span class="sd">        :type inputs: str | list[str] | None</span>
<span class="sd">        :param outputs: model outputs (TF only), defaults to None</span>
<span class="sd">        :type outputs: str | list[str] | None</span>
<span class="sd">        :raises RedisReplyError: if model fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;backend&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="s2">&quot;batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_size</span><span class="p">,</span> <span class="s2">&quot;min_batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_timeout</span><span class="p">,</span> <span class="s2">&quot;min_batch_timeout&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_model_multigpu</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">backend</span><span class="p">,</span>
            <span class="n">first_gpu</span><span class="p">,</span>
            <span class="n">num_gpus</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="p">,</span>
            <span class="n">min_batch_size</span><span class="p">,</span>
            <span class="n">min_batch_timeout</span><span class="p">,</span>
            <span class="n">tag</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_model_from_file"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_model_from_file">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_model_from_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">model_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a TF, TF-lite, PT, or ONNX model from file in the database</span>

<span class="sd">        The final model key used to store the model</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. Similarly, the tensor names in the</span>
<span class="sd">        input and output nodes for TF models may be prefixed.</span>
<span class="sd">        See set_data_source(), use_model_ensemble_prefix(), and</span>
<span class="sd">        use_tensor_ensemble_prefix() for more details.</span>
<span class="sd">        Device selection is either &quot;GPU&quot; or &quot;CPU&quot;. If many GPUs are present,</span>
<span class="sd">        a zero-based index can be passed for specification e.g. &quot;GPU:1&quot;.</span>

<span class="sd">        :param name: name to store model under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param model_file: serialized model</span>
<span class="sd">        :type model_file: file path to model</span>
<span class="sd">        :param backend: name of the backend (TORCH, TF, TFLITE, ONNX)</span>
<span class="sd">        :type backend: str</span>
<span class="sd">        :param device: name of device for execution, defaults to &quot;CPU&quot;</span>
<span class="sd">        :type device: str, optional</span>
<span class="sd">        :param batch_size: batch size for execution, defaults to 0</span>
<span class="sd">        :type batch_size: int, optional</span>
<span class="sd">        :param min_batch_size: minimum batch size for model execution, defaults to 0</span>
<span class="sd">        :type min_batch_size: int, optional</span>
<span class="sd">        :param min_batch_timeout: Max time (ms) to wait for min batch size</span>
<span class="sd">        :type min_batch_timeout: int, optional</span>
<span class="sd">        :param tag: additional tag for model information, defaults to &quot;&quot;</span>
<span class="sd">        :type tag: str, optional</span>
<span class="sd">        :param inputs: model inputs (TF only), defaults to None</span>
<span class="sd">        :type inputs: str | list[str] | None</span>
<span class="sd">        :param outputs: model outupts (TF only), defaults to None</span>
<span class="sd">        :type outputs: str | list[str] | None</span>
<span class="sd">        :raises RedisReplyError: if model fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">model_file</span><span class="p">,</span> <span class="s2">&quot;model_file&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;backend&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="s2">&quot;batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_size</span><span class="p">,</span> <span class="s2">&quot;min_batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_timeout</span><span class="p">,</span> <span class="s2">&quot;min_batch_timeout&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
        <span class="n">m_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_file</span><span class="p">(</span><span class="n">model_file</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_model_from_file</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">m_file</span><span class="p">,</span>
            <span class="n">backend</span><span class="p">,</span>
            <span class="n">device</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="p">,</span>
            <span class="n">min_batch_size</span><span class="p">,</span>
            <span class="n">min_batch_timeout</span><span class="p">,</span>
            <span class="n">tag</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_model_from_file_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_model_from_file_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_model_from_file_multigpu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">model_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_batch_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a TF, TF-lite, PT, or ONNX model from file in the database</span>
<span class="sd">        for use in a multi-GPU system</span>

<span class="sd">        The final model key used to store the model</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. Similarly, the tensor names in the</span>
<span class="sd">        input and output nodes for TF models may be prefixed.</span>
<span class="sd">        See set_data_source(), use_model_ensemble_prefix(), and</span>
<span class="sd">        use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name to store model under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param model_file: serialized model</span>
<span class="sd">        :type model_file: file path to model</span>
<span class="sd">        :param backend: name of the backend (TORCH, TF, TFLITE, ONNX)</span>
<span class="sd">        :type backend: str</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this model</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of GPUs to use in processing this model</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :param batch_size: batch size for execution, defaults to 0</span>
<span class="sd">        :type batch_size: int, optional</span>
<span class="sd">        :param min_batch_size: minimum batch size for model execution, defaults to 0</span>
<span class="sd">        :type min_batch_size: int, optional</span>
<span class="sd">        :param min_batch_timeout: Max time (ms) to wait for min batch size</span>
<span class="sd">        :type min_batch_timeout: int, optional</span>
<span class="sd">        :param tag: additional tag for model information, defaults to &quot;&quot;</span>
<span class="sd">        :type tag: str, optional</span>
<span class="sd">        :param inputs: model inputs (TF only), defaults to None</span>
<span class="sd">        :type inputs: str | list[str] | None</span>
<span class="sd">        :param outputs: model outupts (TF only), defaults to None</span>
<span class="sd">        :type outputs: str | list[str] | None</span>
<span class="sd">        :raises RedisReplyError: if model fails to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">model_file</span><span class="p">,</span> <span class="s2">&quot;model_file&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;backend&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="s2">&quot;batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_size</span><span class="p">,</span> <span class="s2">&quot;min_batch_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">min_batch_timeout</span><span class="p">,</span> <span class="s2">&quot;min_batch_timeout&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
        <span class="n">m_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_file</span><span class="p">(</span><span class="n">model_file</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_model_from_file_multigpu</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">m_file</span><span class="p">,</span>
            <span class="n">backend</span><span class="p">,</span>
            <span class="n">first_gpu</span><span class="p">,</span>
            <span class="n">num_gpus</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="p">,</span>
            <span class="n">min_batch_size</span><span class="p">,</span>
            <span class="n">min_batch_timeout</span><span class="p">,</span>
            <span class="n">tag</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.run_model"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.run_model">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">run_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute a stored model</span>

<span class="sd">        The model key used to locate the model to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name for stored model</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param inputs: names of stored inputs to provide model, defaults to None</span>
<span class="sd">        :type inputs: str | list[str] | None</span>
<span class="sd">        :param outputs: names to store outputs under, defaults to None</span>
<span class="sd">        :type outputs: str | list[str] | None</span>
<span class="sd">        :raises RedisReplyError: if model execution fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">run_model</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.run_model_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.run_model_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">run_model_multigpu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute a model stored for a multi-GPU system</span>

<span class="sd">        The model key used to locate the model to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: name for stored model</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param offset: index of the current image, such as a processor ID</span>
<span class="sd">                         or MPI rank</span>
<span class="sd">        :type offset: int</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this model</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of gpus for which the model was stored</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :param inputs: names of stored inputs to provide model, defaults to None</span>
<span class="sd">        :type inputs: str | list[str] | None</span>
<span class="sd">        :param outputs: names to store outputs under, defaults to None</span>
<span class="sd">        :type outputs: str | list[str] | None</span>
<span class="sd">        :raises RedisReplyError: if model execution fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_tensor_args</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">run_model_multigpu</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">,</span> <span class="n">num_gpus</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.delete_model"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.delete_model">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">delete_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a model from the database</span>

<span class="sd">        The model key used to locate the script to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_model_ensemble_prefix()</span>
<span class="sd">        for more details</span>

<span class="sd">        :param name: the name the model is stored under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :raises RedisReplyError: if model deletion fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">delete_model</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.delete_model_multigpu"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.delete_model_multigpu">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">delete_model_multigpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a model from the database that was stored for use with multiple GPUs</span>

<span class="sd">        The model key used to locate the script to be run</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_model_ensemble_prefix()</span>
<span class="sd">        for more details</span>

<span class="sd">        :param name: the name the model is stored under</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param first_gpu: the first GPU (zero-based) to use in processing this model</span>
<span class="sd">        :type first_gpu: int</span>
<span class="sd">        :param num_gpus: the number of gpus for which the model was stored</span>
<span class="sd">        :type num_gpus: int</span>
<span class="sd">        :raises RedisReplyError: if model deletion fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">first_gpu</span><span class="p">,</span> <span class="s2">&quot;first_gpu&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_gpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">delete_model_multigpu</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">first_gpu</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.tensor_exists"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.tensor_exists">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">tensor_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a tensor exists in the database</span>

<span class="sd">        The tensor key used to check for existence</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: The tensor name that will be checked in the database</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :returns: Returns true if the tensor exists in the database</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if checking for tensor existence causes an error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">tensor_exists</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.dataset_exists"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.dataset_exists">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">dataset_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a dataset exists in the database</span>

<span class="sd">        The dataset key used to check for existence</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_dataset_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: The dataset name that will be checked in the database</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :returns: Returns true if the dataset exists in the database</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if `dataset_exists` fails (i.e. causes an error)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">dataset_exists</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.model_exists"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.model_exists">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">model_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a model or script exists in the database</span>

<span class="sd">        The model or script key used to check for existence</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: The model or script name that will be checked in the database</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :returns: Returns true if the model exists in the database</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if `model_exists` fails (i.e. causes an error)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">model_exists</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.key_exists"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.key_exists">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">key_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the key exists in the database</span>

<span class="sd">        :param key: The key that will be checked in the database</span>
<span class="sd">        :type key: str</span>
<span class="sd">        :returns: Returns true if the key exists in the database</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if `key_exists` fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">key_exists</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.poll_key"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.poll_key">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">poll_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the key exists in the database</span>

<span class="sd">        The check is repeated at a specified polling interval and for</span>
<span class="sd">        a specified number of retries.</span>

<span class="sd">        :param key: The key that will be checked in the database</span>
<span class="sd">        :type key: str</span>
<span class="sd">        :param poll_frequency_ms: The polling interval, in milliseconds</span>
<span class="sd">        :type poll_frequency_ms: int</span>
<span class="sd">        :param num_tries: The total number of retries for the check</span>
<span class="sd">        :type num_tries: int</span>
<span class="sd">        :returns: Returns true if the key is found within the</span>
<span class="sd">                  specified number of tries, otherwise false.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if an error occurs while polling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="s2">&quot;poll_frequency_ms&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_tries</span><span class="p">,</span> <span class="s2">&quot;num_tries&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">poll_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.poll_tensor"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.poll_tensor">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">poll_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a tensor exists in the database</span>

<span class="sd">        The check is repeated at a specified polling interval and for</span>
<span class="sd">        a specified number of retries.</span>
<span class="sd">        The tensor key used to check for existence</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_tensor_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: The tensor name that will be checked in the database</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param poll_frequency_ms: The polling interval, in milliseconds</span>
<span class="sd">        :type poll_frequency_ms: int</span>
<span class="sd">        :param num_tries: The total number of retries for the check</span>
<span class="sd">        :type num_tries: int</span>
<span class="sd">        :returns: Returns true if the tensor key is found within the</span>
<span class="sd">                  specified number of tries, otherwise false.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if an error occurs while polling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="s2">&quot;poll_frequency_ms&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_tries</span><span class="p">,</span> <span class="s2">&quot;num_tries&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">poll_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.poll_dataset"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.poll_dataset">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">poll_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a dataset exists in the database</span>

<span class="sd">        The check is repeated at a specified polling interval and for</span>
<span class="sd">        a specified number of retries.</span>
<span class="sd">        The dataset key used to check for existence</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_dataset_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: The dataset name that will be checked in the database</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param poll_frequency_ms: The polling interval, in milliseconds</span>
<span class="sd">        :type poll_frequency_ms: int</span>
<span class="sd">        :param num_tries: The total number of retries for the check</span>
<span class="sd">        :type num_tries: int</span>
<span class="sd">        :returns: Returns true if the key is found within the</span>
<span class="sd">                  specified number of tries, otherwise false.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if an error occurs while polling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="s2">&quot;poll_frequency_ms&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_tries</span><span class="p">,</span> <span class="s2">&quot;num_tries&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">poll_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.poll_model"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.poll_model">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">poll_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a model or script exists in the database</span>

<span class="sd">        The check is repeated at a specified polling interval and for</span>
<span class="sd">        a specified number of retries.</span>
<span class="sd">        The model or script key used to check for existence</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()</span>
<span class="sd">        and use_model_ensemble_prefix() for more details.</span>

<span class="sd">        :param name: The model or script name that will be checked in the database</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param poll_frequency_ms: The polling interval, in milliseconds</span>
<span class="sd">        :type poll_frequency_ms: int</span>
<span class="sd">        :param num_tries: The total number of retries for the check</span>
<span class="sd">        :type num_tries: int</span>
<span class="sd">        :returns: Returns true if the key is found within the</span>
<span class="sd">                  specified number of tries, otherwise false.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if an error occurs while polling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="s2">&quot;poll_frequency_ms&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_tries</span><span class="p">,</span> <span class="s2">&quot;num_tries&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">poll_model</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_data_source"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_data_source">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_data_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the data source, a key prefix for future operations</span>

<span class="sd">        When running multiple applications, such as an ensemble</span>
<span class="sd">        computation, there is a risk that the same name is used</span>
<span class="sd">        for a tensor, dataset, script, or model by more than one</span>
<span class="sd">        executing entity. In order to prevent this sort of collision,</span>
<span class="sd">        SmartRedis affords the ability to add a prefix to names,</span>
<span class="sd">        thereby associating them with the name of the specific</span>
<span class="sd">        entity that the prefix corresponds to. For writes to</span>
<span class="sd">        the database when prefixing is activated, the prefix</span>
<span class="sd">        used is taken from the SSKEYOUT environment variable.</span>
<span class="sd">        For reads from the database, the default is to use the</span>
<span class="sd">        first prefix from SSKEYIN. If this is the same as the</span>
<span class="sd">        prefix from SSKEYOUT, the entity will read back the</span>
<span class="sd">        same data it wrote; however, this function allows an entity</span>
<span class="sd">        to read from data written by another entity (i.e. use</span>
<span class="sd">        the other entity&#39;s key.)</span>

<span class="sd">        :param source_id: The prefix for read operations; must have</span>
<span class="sd">                          previously been set via the SSKEYIN environment</span>
<span class="sd">                          variable</span>
<span class="sd">        :type source_id: str</span>
<span class="sd">        :raises RedisReplyError: if set data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="s2">&quot;source_id&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_data_source</span><span class="p">(</span><span class="n">source_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.use_model_ensemble_prefix"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.use_model_ensemble_prefix">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">use_model_ensemble_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Control whether model and script keys are</span>
<span class="sd">           prefixed (e.g. in an ensemble) when forming database keys</span>

<span class="sd">        This function can be used to avoid key collisions in an ensemble</span>
<span class="sd">        by prepending the string value from the environment variable SSKEYIN</span>
<span class="sd">        to model and script names.</span>
<span class="sd">        Prefixes will only be used if they were previously set through</span>
<span class="sd">        environment variables SSKEYIN and SSKEYOUT.</span>
<span class="sd">        Keys for entities created before this function is called</span>
<span class="sd">        will not be retroactively prefixed.</span>
<span class="sd">        By default, the client does not prefix model and script</span>
<span class="sd">        keys.</span>

<span class="sd">        :param use_prefix: If set to true, all future operations</span>
<span class="sd">                           on models and scripts will use a prefix, if</span>
<span class="sd">                           available.</span>
<span class="sd">        :type use_prefix: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">,</span> <span class="s2">&quot;use_prefix&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">use_model_ensemble_prefix</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.use_list_ensemble_prefix"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.use_list_ensemble_prefix">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">use_list_ensemble_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Control whether aggregation lists are prefixed</span>
<span class="sd">           when forming database keys</span>

<span class="sd">        This function can be used to avoid key collisions in an</span>
<span class="sd">        ensemble by prepending the string value from the</span>
<span class="sd">        environment variable SSKEYIN and/or SSKEYOUT to</span>
<span class="sd">        aggregation list names.  Prefixes will only be used if</span>
<span class="sd">        they were previously set through the environment variables</span>
<span class="sd">        SSKEYOUT and SSKEYIN. Keys for aggregation lists created</span>
<span class="sd">        before this function is called will not be retroactively</span>
<span class="sd">        prefixed. By default, the client prefixes aggregation</span>
<span class="sd">        list keys with the first prefix specified with the SSKEYIN</span>
<span class="sd">        and SSKEYOUT environment variables.  Note that</span>
<span class="sd">        use_dataset_ensemble_prefix() controls prefixing</span>
<span class="sd">        for the entities in the aggregation list, and</span>
<span class="sd">        use_dataset_ensemble_prefix() should be given the</span>
<span class="sd">        same value that was used during the initial</span>
<span class="sd">        setting of the DataSet into the database.</span>

<span class="sd">        :param use_prefix: If set to true, all future operations</span>
<span class="sd">                           on aggregation lists will use a prefix, if</span>
<span class="sd">                           available.</span>
<span class="sd">        :type use_prefix: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">,</span> <span class="s2">&quot;use_prefix&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">use_list_ensemble_prefix</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.use_tensor_ensemble_prefix"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.use_tensor_ensemble_prefix">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">use_tensor_ensemble_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Control whether tensor keys are prefixed (e.g. in an</span>
<span class="sd">        ensemble) when forming database keys</span>

<span class="sd">        This function can be used to avoid key collisions in an ensemble</span>
<span class="sd">        by prepending the string value from the environment variable SSKEYIN</span>
<span class="sd">        to tensor names.</span>
<span class="sd">        Prefixes will only be used if they were previously set through</span>
<span class="sd">        environment variables SSKEYIN and SSKEYOUT.</span>
<span class="sd">        Keys for entities created before this function is called</span>
<span class="sd">        will not be retroactively prefixed.</span>
<span class="sd">        By default, the client prefixes tensor keys when a prefix is</span>
<span class="sd">        available.</span>

<span class="sd">        :param use_prefix: If set to true, all future operations on tensors</span>
<span class="sd">                           will use a prefix, if available.</span>
<span class="sd">        :type use_prefix: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">,</span> <span class="s2">&quot;use_prefix&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">use_tensor_ensemble_prefix</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.use_dataset_ensemble_prefix"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.use_dataset_ensemble_prefix">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">use_dataset_ensemble_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Control whether dataset keys are prefixed (e.g. in an ensemble)</span>
<span class="sd">           when forming database keys</span>

<span class="sd">        This function can be used to avoid key collisions in an ensemble</span>
<span class="sd">        by prepending the string value from the environment variable SSKEYIN</span>
<span class="sd">        to dataset names.</span>
<span class="sd">        Prefixes will only be used if they were previously set through</span>
<span class="sd">        environment variables SSKEYIN and SSKEYOUT.</span>
<span class="sd">        Keys for entities created before this function is called</span>
<span class="sd">        will not be retroactively prefixed.</span>
<span class="sd">        By default, the client prefixes dataset keys when a prefix is</span>
<span class="sd">        available.</span>

<span class="sd">        :param use_prefix: If set to true, all future operations on datasets</span>
<span class="sd">                           will use a prefix, if available.</span>
<span class="sd">        :type use_prefix: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">,</span> <span class="s2">&quot;use_prefix&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">use_dataset_ensemble_prefix</span><span class="p">(</span><span class="n">use_prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_db_node_info"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_db_node_info">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_db_node_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addresses</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns information about given database nodes</span>

<span class="sd">        :param addresses: The addresses of the database nodes</span>
<span class="sd">        :type address: list[str]</span>
<span class="sd">        :returns: A list of dictionaries with each entry in the</span>
<span class="sd">                  list corresponding to an address reply</span>
<span class="sd">        :rtype: list[dict]</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution or the address</span>
<span class="sd">                is not reachable by the client.</span>
<span class="sd">                In the case of using a cluster of database nodes,</span>
<span class="sd">                it is best practice to bind each node in the cluster</span>
<span class="sd">                to a specific address to avoid inconsistencies in</span>
<span class="sd">                addresses retrieved with the CLUSTER SLOTS command.</span>
<span class="sd">                Inconsistencies in node addresses across</span>
<span class="sd">                CLUSTER SLOTS commands can lead to RedisReplyError</span>
<span class="sd">                being thrown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="s2">&quot;addresses&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_db_node_info</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_db_cluster_info"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_db_cluster_info">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_db_cluster_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addresses</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns cluster information from a specified db node.</span>
<span class="sd">        If the address does not correspond to a cluster node,</span>
<span class="sd">        an empty dictionary is returned.</span>

<span class="sd">        :param addresses: The addresses of the database nodes</span>
<span class="sd">        :type address: list[str]</span>
<span class="sd">        :returns: A list of dictionaries with each entry in the</span>
<span class="sd">                  list corresponding to an address reply</span>
<span class="sd">        :rtype: list[dict]</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution or the address</span>
<span class="sd">                is not reachable by the client or if on a</span>
<span class="sd">                non-cluster environment.</span>
<span class="sd">                In the case of using a cluster of database nodes,</span>
<span class="sd">                it is best practice to bind each node in the cluster</span>
<span class="sd">                to a specific address to avoid inconsistencies in</span>
<span class="sd">                addresses retrieved with the CLUSTER SLOTS command.</span>
<span class="sd">                Inconsistencies in node addresses across</span>
<span class="sd">                CLUSTER SLOTS commands can lead to RedisReplyError</span>
<span class="sd">                being thrown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="s2">&quot;addresses&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_db_cluster_info</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_ai_info"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_ai_info">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_ai_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reset_stat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns AI.INFO command reply information for the</span>
<span class="sd">        script or model key at the provided addresses.</span>

<span class="sd">        :param addresses: The addresses of the database nodes</span>
<span class="sd">        :type address: list[str]</span>
<span class="sd">        :param key: The key associated with the model or script</span>
<span class="sd">        :type key: str</span>
<span class="sd">        :param reset_stat: Boolean indicating if the statistics</span>
<span class="sd">                           for the model or script should be</span>
<span class="sd">                           reset.</span>
<span class="sd">        :type reset_stat: bool</span>
<span class="sd">        :returns: A list of dictionaries with each entry in the</span>
<span class="sd">                  list corresponding to an address reply</span>
<span class="sd">        :rtype: list[dict]</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution or parsing the command reply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">reset_stat</span><span class="p">,</span> <span class="s2">&quot;reset_stat&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_ai_info</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">reset_stat</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.flush_db"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.flush_db">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">flush_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addresses</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all keys from a specified db node.</span>

<span class="sd">        :param addresses: The addresses of the database nodes</span>
<span class="sd">        :type address: list[str]</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution or the address</span>
<span class="sd">                is not reachable by the client.</span>
<span class="sd">                In the case of using a cluster of database nodes,</span>
<span class="sd">                it is best practice to bind each node in the cluster</span>
<span class="sd">                to a specific address to avoid inconsistencies in</span>
<span class="sd">                addresses retrieved with the CLUSTER SLOTS command.</span>
<span class="sd">                Inconsistencies in node addresses across</span>
<span class="sd">                CLUSTER SLOTS commands can lead to RedisReplyError</span>
<span class="sd">                being thrown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="s2">&quot;addresses&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">flush_db</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.config_get"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.config_get">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">config_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the configuration parameters of a running server.</span>
<span class="sd">        If the address does not correspond to a cluster node,</span>
<span class="sd">        an empty dictionary is returned.</span>

<span class="sd">        :param expression: Parameter used in the configuration or a</span>
<span class="sd">                           glob pattern (Use &#39;*&#39; to retrieve all</span>
<span class="sd">                           configuration parameters)</span>
<span class="sd">        :type expression: str</span>
<span class="sd">        :param address: The address of the database node</span>
<span class="sd">        :type address: str</span>
<span class="sd">        :returns: A dictionary that maps configuration parameters to</span>
<span class="sd">                  their values. If the provided expression does not</span>
<span class="sd">                  exist, then an empty dictionary is returned.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution or the address</span>
<span class="sd">                is not reachable by the client.</span>
<span class="sd">                In the case of using a cluster of database nodes,</span>
<span class="sd">                it is best practice to bind each node in the cluster</span>
<span class="sd">                to a specific address to avoid inconsistencies in</span>
<span class="sd">                addresses retrieved with the CLUSTER SLOTS command.</span>
<span class="sd">                Inconsistencies in node addresses across</span>
<span class="sd">                CLUSTER SLOTS commands can lead to RedisReplyError</span>
<span class="sd">                being thrown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="s2">&quot;expression&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">config_get</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.config_set"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.config_set">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">config_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config_param</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconfigure the server. It can change both trivial</span>
<span class="sd">        parameters or switch from one to another persistence option.</span>
<span class="sd">        All the configuration parameters set using this command are</span>
<span class="sd">        immediately loaded by Redis and will take effect starting with</span>
<span class="sd">        the next command executed.</span>
<span class="sd">        If the address does not correspond to a cluster node,</span>
<span class="sd">        an empty dictionary is returned.</span>

<span class="sd">        :param config_param: A configuration parameter to set</span>
<span class="sd">        :type config_param: str</span>
<span class="sd">        :param value: The value to assign to the configuration parameter</span>
<span class="sd">        :type value: str</span>
<span class="sd">        :param address: The address of the database node</span>
<span class="sd">        :type address: str</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution or the address</span>
<span class="sd">                is not reachable by the client or if the config_param</span>
<span class="sd">                is unsupported. In the case of using a cluster of</span>
<span class="sd">                database nodes, it is best practice to bind each node</span>
<span class="sd">                in the cluster to a specific address to avoid inconsistencies</span>
<span class="sd">                in addresses retrieved with the CLUSTER SLOTS command.</span>
<span class="sd">                Inconsistencies in node addresses across</span>
<span class="sd">                CLUSTER SLOTS commands can lead to RedisReplyError</span>
<span class="sd">                being thrown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">config_param</span><span class="p">,</span> <span class="s2">&quot;config_param&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">config_set</span><span class="p">(</span><span class="n">config_param</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.save"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.save">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addresses</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a synchronous save of the database shard</span>
<span class="sd">        producing a point in time snapshot of all the data</span>
<span class="sd">        inside the Redis instance, in the form of an RBD file.</span>

<span class="sd">        :param addresses: The addresses of the database nodes</span>
<span class="sd">        :type addresses: list[str]</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution or the address</span>
<span class="sd">                is not reachable by the client.</span>
<span class="sd">                In the case of using a cluster of database nodes,</span>
<span class="sd">                it is best practice to bind each node in the cluster</span>
<span class="sd">                to a specific address to avoid inconsistencies in</span>
<span class="sd">                addresses retrieved with the CLUSTER SLOTS command.</span>
<span class="sd">                Inconsistencies in node addresses across</span>
<span class="sd">                CLUSTER SLOTS commands can lead to RedisReplyError</span>
<span class="sd">                being thrown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="s2">&quot;addresses&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.set_model_chunk_size"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.set_model_chunk_size">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">set_model_chunk_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconfigures the chunking size that Redis uses for model</span>
<span class="sd">           serialization, replication, and the model_get command.</span>
<span class="sd">           This method triggers the AI.CONFIG method in the Redis</span>
<span class="sd">           database to change the model chunking size.</span>

<span class="sd">           NOTE: The default size of 511MB should be fine for most</span>
<span class="sd">           applications, so it is expected to be very rare that a</span>
<span class="sd">           client calls this method. It is not necessary to call</span>
<span class="sd">           this method for a model to be chunked.</span>

<span class="sd">        :param chunk_size: The new chunk size in bytes</span>
<span class="sd">        :type addresses: int</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">,</span> <span class="s2">&quot;chunk_size&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_model_chunk_size</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.append_to_list"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.append_to_list">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">append_to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Appends a dataset to the aggregation list</span>

<span class="sd">        When appending a dataset to an aggregation list,</span>
<span class="sd">        the list will automatically be created if it does not</span>
<span class="sd">        exist (i.e. this is the first entry in the list).</span>
<span class="sd">        Aggregation lists work by referencing the dataset</span>
<span class="sd">        by storing its key, so appending a dataset</span>
<span class="sd">        to an aggregation list does not create a copy of the</span>
<span class="sd">        dataset.  Also, for this reason, the dataset</span>
<span class="sd">        must have been previously placed into the database</span>
<span class="sd">        with a separate call to put_dataset().</span>

<span class="sd">        :param list_name: The name of the aggregation list</span>
<span class="sd">        :type list_name: str</span>
<span class="sd">        :param dataset: The DataSet to append</span>
<span class="sd">        :type dataset: Dataset</span>
<span class="sd">        :raises TypeError: if argument is not a Dataset</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span> <span class="s2">&quot;list_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;dataset&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">)</span>
        <span class="n">pybind_dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">append_to_list</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span> <span class="n">pybind_dataset</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.delete_list"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.delete_list">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">delete_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete an aggregation list</span>

<span class="sd">        The key used to locate the aggregation list to be</span>
<span class="sd">        deleted may be formed by applying a prefix to the</span>
<span class="sd">        supplied name. See set_data_source()</span>
<span class="sd">        and use_list_ensemble_prefix() for more details.</span>

<span class="sd">        :param list_name: The name of the aggregation list</span>
<span class="sd">        :type list_name: str</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span> <span class="s2">&quot;list_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">delete_list</span><span class="p">(</span><span class="n">list_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.copy_list"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.copy_list">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">copy_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy an aggregation list</span>

<span class="sd">        The source and destination aggregation list keys used to</span>
<span class="sd">        locate and store the aggregation list may be formed by</span>
<span class="sd">        applying prefixes to the supplied src_name and dest_name.</span>
<span class="sd">        See set_data_source() and use_list_ensemble_prefix()</span>
<span class="sd">        for more details.</span>

<span class="sd">        :param src_name: The source list name</span>
<span class="sd">        :type src_name: str</span>
<span class="sd">        :param dest_name: The destination list name</span>
<span class="sd">        :type dest_name: str</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="s2">&quot;src_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s2">&quot;dest_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">copy_list</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.rename_list"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.rename_list">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">rename_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rename an aggregation list</span>

<span class="sd">        The old and new aggregation list key used to find and</span>
<span class="sd">        relocate the list may be formed by applying prefixes to</span>
<span class="sd">        the supplied old_name and new_name. See set_data_source()</span>
<span class="sd">        and use_list_ensemble_prefix() for more details.</span>

<span class="sd">        :param src_name: The source list name</span>
<span class="sd">        :type src_name: str</span>
<span class="sd">        :param dest_name: The destination list name</span>
<span class="sd">        :type dest_name: str</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="s2">&quot;src_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s2">&quot;dest_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">rename_list</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_list_length"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_list_length">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_list_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of entries in the list</span>

<span class="sd">        :param list_name: The list name</span>
<span class="sd">        :type list_name: str</span>
<span class="sd">        :return: The length of the list</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span> <span class="s2">&quot;list_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_list_length</span><span class="p">(</span><span class="n">list_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.poll_list_length"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.poll_list_length">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">poll_list_length</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">list_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Poll list length until length is equal</span>
<span class="sd">        to the provided length.  If maximum number of</span>
<span class="sd">        attempts is exceeded, returns False</span>

<span class="sd">        The aggregation list key used to check for list length</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_list_ensemble_prefix()</span>
<span class="sd">        for more details.</span>

<span class="sd">        :param name: The name of the list</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param list_length: The desired length of the list</span>
<span class="sd">        :type list_length: int</span>
<span class="sd">        :param poll_frequency_ms: The time delay between checks, in milliseconds</span>
<span class="sd">        :type poll_frequency_ms: int</span>
<span class="sd">        :param num_tries: The total number of times to check for the name</span>
<span class="sd">        :type num_tries: int</span>
<span class="sd">        :return: Returns true if the list is found with a length greater</span>
<span class="sd">                than or equal to the provided length, otherwise false</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_length</span><span class="p">,</span> <span class="s2">&quot;list_length&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="s2">&quot;poll_frequency_ms&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_tries</span><span class="p">,</span> <span class="s2">&quot;num_tries&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">poll_list_length</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">list_length</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="n">num_tries</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.poll_list_length_gte"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.poll_list_length_gte">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">poll_list_length_gte</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">list_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Poll list length until length is greater than or equal</span>
<span class="sd">        to the user-provided length. If maximum number of</span>
<span class="sd">        attempts is exceeded, false is returned.</span>

<span class="sd">        The aggregation list key used to check for list length</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_list_ensemble_prefix()</span>
<span class="sd">        for more details.</span>

<span class="sd">        :param name: The name of the list</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param list_length: The desired minimum length of the list</span>
<span class="sd">        :type list_length: int</span>
<span class="sd">        :param poll_frequency_ms: The time delay between checks, in milliseconds</span>
<span class="sd">        :type poll_frequency_ms: int</span>
<span class="sd">        :param num_tries: The total number of times to check for the name</span>
<span class="sd">        :type num_tries: int</span>
<span class="sd">        :return: Returns true if the list is found with a length greater</span>
<span class="sd">                 than or equal to the provided length, otherwise false</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_length</span><span class="p">,</span> <span class="s2">&quot;list_length&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="s2">&quot;poll_frequency_ms&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_tries</span><span class="p">,</span> <span class="s2">&quot;num_tries&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">poll_list_length_gte</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">list_length</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="n">num_tries</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.poll_list_length_lte"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.poll_list_length_lte">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">poll_list_length_lte</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">list_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_tries</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Poll list length until length is less than or equal</span>
<span class="sd">        to the user-provided length. If maximum number of</span>
<span class="sd">        attempts is exceeded, false is returned.</span>

<span class="sd">        The aggregation list key used to check for list length</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_list_ensemble_prefix()</span>
<span class="sd">        for more details.</span>

<span class="sd">        :param name: The name of the list</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param list_length: The desired maximum length of the list</span>
<span class="sd">        :type list_length: int</span>
<span class="sd">        :param poll_frequency_ms: The time delay between checks, in milliseconds</span>
<span class="sd">        :type poll_frequency_ms: int</span>
<span class="sd">        :param num_tries: The total number of times to check for the name</span>
<span class="sd">        :type num_tries: int</span>
<span class="sd">        :return: Returns true if the list is found with a length less</span>
<span class="sd">                 than or equal to the provided length, otherwise false</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises RedisReplyError: if there is an error</span>
<span class="sd">                in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_length</span><span class="p">,</span> <span class="s2">&quot;list_length&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="s2">&quot;poll_frequency_ms&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">num_tries</span><span class="p">,</span> <span class="s2">&quot;num_tries&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">poll_list_length_lte</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">list_length</span><span class="p">,</span> <span class="n">poll_frequency_ms</span><span class="p">,</span> <span class="n">num_tries</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_datasets_from_list"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_datasets_from_list">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_datasets_from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get datasets from an aggregation list</span>

<span class="sd">        The aggregation list key used to retrieve datasets</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source() and use_list_ensemble_prefix()</span>
<span class="sd">        for more details.  An empty or nonexistant</span>
<span class="sd">        aggregation list returns an empty vector.</span>

<span class="sd">        :param list_name: The name of the list</span>
<span class="sd">        :type list_name: str</span>
<span class="sd">        :return: A list of DataSet objects.</span>
<span class="sd">        :rtype: list[DataSet]</span>
<span class="sd">        :raises RedisReplyError: if there is an error in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span> <span class="s2">&quot;list_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_datasets_from_list</span><span class="p">(</span><span class="n">list_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_dataset_list_range"><a class="viewcode-back" href="../../api/smartredis_api.html#smartredis.Client.get_dataset_list_range">[docs]</a>    <span class="nd">@exception_handler</span>
    <span class="k">def</span> <span class="nf">get_dataset_list_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">list_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end_index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a range of datasets (by index) from an aggregation list</span>

<span class="sd">        The aggregation list key used to retrieve datasets</span>
<span class="sd">        may be formed by applying a prefix to the supplied</span>
<span class="sd">        name. See set_data_source()  and use_list_ensemble_prefix()</span>
<span class="sd">        for more details.  An empty or nonexistant aggregation</span>
<span class="sd">        list returns an empty vector.  If the provided</span>
<span class="sd">        end_index is beyond the end of the list, that index will</span>
<span class="sd">        be treated as the last index of the list.  If start_index</span>
<span class="sd">        and end_index are inconsistent (e.g. end_index is less</span>
<span class="sd">        than start_index), an empty list of datasets will be returned.</span>

<span class="sd">        :param list_name: The name of the list</span>
<span class="sd">        :type list_name: str</span>
<span class="sd">        :param start_index: The starting index of the range (inclusive,</span>
<span class="sd">               starting at zero).  Negative values are</span>
<span class="sd">               supported.  A negative value indicates offsets</span>
<span class="sd">               starting at the end of the list. For example, -1 is</span>
<span class="sd">               the last element of the list.</span>
<span class="sd">        :type start_index: int</span>
<span class="sd">        :param end_index: The ending index of the range (inclusive,</span>
<span class="sd">               starting at zero).  Negative values are</span>
<span class="sd">               supported.  A negative value indicates offsets</span>
<span class="sd">               starting at the end of the list. For example, -1 is</span>
<span class="sd">               the last element of the list.</span>
<span class="sd">        :return: A list of DataSet objects.</span>
<span class="sd">        :rtype: list[DataSet]</span>
<span class="sd">        :raises RedisReplyError: if there is an error in command execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span> <span class="s2">&quot;list_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="s2">&quot;start_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">typecheck</span><span class="p">(</span><span class="n">end_index</span><span class="p">,</span> <span class="s2">&quot;end_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">get_dataset_list_range</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span></div>

    <span class="c1"># ---- helpers --------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__check_tensor_args</span><span class="p">(</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">init_default</span><span class="p">([],</span> <span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">init_default</span><span class="p">([],</span> <span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputs</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__check_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;TF&quot;</span><span class="p">,</span> <span class="s2">&quot;TFLITE&quot;</span><span class="p">,</span> <span class="s2">&quot;TORCH&quot;</span><span class="p">,</span> <span class="s2">&quot;ONNX&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">backend</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Backend type </span><span class="si">{</span><span class="n">backend</span><span class="si">}</span><span class="s2"> unsupported&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__check_file</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">osp</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">file_path</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__check_device</span><span class="p">(</span><span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">device</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">device</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;GPU&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Device argument must start with either CPU or GPU&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">device</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__set_address</span><span class="p">(</span><span class="n">address</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;SSDB&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;SSDB&quot;</span><span class="p">]</span>
        <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;SSDB&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">address</span></div>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Cray Labs
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2021-2024, Hewlett Packard Enterprise.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  Questions? You can contact <a href="mailto:craylabs@hpe.com">contact us</a> or <a href="https://join.slack.com/t/craylabs/shared_invite/zt-nw3ag5z5-5PS4tIXBfufu1bIvvr71UA">join us on Slack!</a>
</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>